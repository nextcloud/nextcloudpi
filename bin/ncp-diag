#!/bin/bash

# NextCloudPi diagnostics report
#
# Copyleft 2017 by Ignacio Nunez Hernanz <nacho _a_t_ ownyourbits _d_o_t_ com>
# GPL licensed (see end of file) * Use at your own risk!
#
# Usage:
#   sudo ncp-diag
#
# More at https://ownyourbits.com
#

source /usr/local/etc/library.sh

# Distro, NCP version and tag
echo "NextCloudPi version|$( cat /usr/local/etc/ncp-version )"
[[ -f /usr/local/etc/ncp-baseimage ]] && echo "NextCloudPi image|$( cat /usr/local/etc/ncp-baseimage )"
echo "OS|$(cat /etc/issue  | sed 's| \\n \\l||'). $(uname -r) ($(uname -m))"

# Data
DATADIR="$( grep datadirectory /var/www/nextcloud/config/config.php |
	    awk '{ print $3 }' | grep -oP "[^']*[^']" | head -1 )"
test -d "$DATADIR" || DIRINFO=" (doesn't exist)"
USBDEVS="$( lsblk -S -o  NAME,TRAN | awk '{ if ( $2 == "usb" ) print $1; }' | tr '\n' ' ' )"
[[ "$USBDEVS" == "" ]] && USBDEVS="none"

am_cfg="/usr/local/etc/ncp-config.d/nc-automount.cfg"
[[ -f "$am_cfg" ]] && [[ "$(jq -r ".params[0].value" "$am_cfg")" == "yes" ]] && echo "automount|yes" || echo "automount|no"
echo "USB devices|$USBDEVS"
echo "datadir|$DATADIR$DIRINFO"
[[ "$DIRINFO" == "" ]] && {
  echo "data in SD|$( [[ $( stat -fc%d / ) == $( stat -fc%d "$DATADIR" ) ]] && echo yes || echo no )"
  echo "data filesystem|$( stat -fc%T $DATADIR )"
  echo "data disk usage|$( df -h "$DATADIR" | tail -1 | awk '{ print $3"/"$2 }')"
}
echo "rootfs usage|$( df -h / | tail -1 | awk '{ print $3"/"$2 }')"
SWP="$( swapon | tail -1 | awk '{ print $1 }' )"
[[ "$SWP" == "" ]] && SWP="none"
echo "swapfile|$SWP"

# Database
DBDIR=$( grep datadir /etc/mysql/mariadb.conf.d/90-ncp.cnf | awk -F "= " '{ print $2 }' )
test -d "$DBDIR" || DBDIRINFO=" (doesn't exist)"
echo "dbdir|$DBDIR$DBDIRINFO"

# Nextcloud
VERSION="$( ncc status | grep "version:" | awk '{ print $3 }' )"
if [[ "$VERSION" != "" ]]; then
  echo "Nextcloud check|ok"
  echo "Nextcloud version|$VERSION"
  else
  echo "Nextcloud check|error"
fi

# Services
echo "HTTPD service|$( pgrep -c apache2 &>/dev/null && echo up || echo down )"
echo "PHP service|$( pgrep -c php-fpm &>/dev/null && echo up || echo down )"
echo "MariaDB service|$( (pgrep -c mysqld || pgrep -c mariadb) &>/dev/null && echo up || echo down )"
echo "Redis service|$( pgrep -c redis-server &>/dev/null && echo up || echo down )"
echo "HPB service|$( ncc notify_push:self-test &>/dev/null && echo up || echo down )"
echo "Postfix service|$( pgrep -fc postfix &>/dev/null && echo up || echo down )"

# WAN
echo "Internet check|$( ping -W 2 -w 1 -q github.com &>/dev/null && echo ok || echo no )"

function is_port_open()
{
  local port port_url port_check_url ip_url tmp_file token token_args grep_token grep_portcheck \
  publicIPv4 publicIPv4_exist ipv4_port_access ipv4_args ipv4_portcheck_args \
  publicIPv6 publicIPv6_exist ipv6_port_access ipv6_args ipv6_portcheck_args
  tmp_file=$(mktemp)
  trap "rm -rf ${tmp_file}; exit $?" EXIT ERR SIGINT SIGQUIT SIGABRT SIGTERM SIGHUP
  
    port="$1"
    publicIPv4_exist=True
    publicIPv6_exist=True
    readonly port_url="https://portchecker.co"
    readonly port_check_url="https://portchecker.co/check"
    readonly ip_url="https://icanhazip.com"
    readonly token_args=(-T2 -t1 -qO- --keep-session-cookies --save-cookies "${tmp_file}" "${port_url}")
    readonly grep_token_args=(-oP "_csrf\" value=\"\K.*\"")
    readonly grep_portcheck_args=(-q '<span class="green">open</span>')
    readonly ipv4_args=(-s -m4 -4 "${ip_url}")
    readonly ipv6_args=(-s -m4 -6 "${ip_url}")
  
    publicIPv4=$(curl "${ipv4_args[@]}" 2>/dev/null) || { publicIPv4_exist=False; }
    publicIPv6=$(curl "${ipv6_args[@]}" 2>/dev/null) || { publicIPv6_exist=False; }
  
    if [[ "${publicIPv4_exist}" == False ]] && [[ "${publicIPv6_exist}" == False ]]
    then
      echo "Error - IPv4 & IPv6: Couldn't get public IP."
      return 1
    fi

    token=$(wget "${token_args[@]}" | grep "${grep_token_args[@]}" )
    readonly ipv4_portcheck_args=(-T2 -t1 -qO- --load-cookies "${tmp_file}" "${port_check_url}" --post-data "target_ip=${publicIPv4}&port=${port}&_csrf=${token::-1}")
    readonly ipv6_portcheck_args=(-T2 -t1 -qO- --load-cookies "${tmp_file}" "${port_check_url}" --post-data "target_ip=${publicIPv6}&port=${port}&_csrf=${token::-1}")
  
    if [[ -n "${token}" ]]
    then
      if [[ "${publicIPv4_exist}" == True ]] && [[ "${publicIPv6_exist}" == False ]]
      then
        grep "${grep_portcheck_args[@]}" <(wget "${ipv4_portcheck_args[@]}") && \
        { ipv4_port_access=True; } || { ipv4_port_access=False; }
      elif [[ "${publicIPv4_exist}" == False ]] && [[ "${publicIPv6_exist}" == True ]]
      then
        grep "${grep_portcheck_args[@]}" <(wget "${ipv6_portcheck_args[@]}") && \
        { ipv6_port_access=True; } || { ipv6_port_access=False; }
      else
        grep "${grep_portcheck_args[@]}" <(wget "${ipv4_portcheck_args[@]}") && \
        { ipv4_port_access=True; } || { ipv4_port_access=False; }
  
        grep "${grep_portcheck_args[@]}" <(wget "${ipv6_portcheck_args[@]}") && \
        { ipv6_port_access=True; } || { ipv6_port_access=False; }
      fi
       
      if [[ "${ipv4_port_access}" == True ]] && [[ "${ipv6_port_access}" == True ]]
      then
        echo "Open. IPv4: ${ipv4_port_access} & IPv6: ${ipv6_port_access}"
        return 0
      elif [[ "${ipv4_port_access}" == False ]] && [[ "${ipv6_port_access}" == False ]]
      then
        echo "Closed. IPv4 & IPv6"
        return 0
      fi
      
      if [[ "${ipv4_port_access}" == True ]] && [[ "${publicIPv6_exist}" == False  ]]
      then
        echo "Open. IPv4: ${ipv4_port_access} & IPv6: N/A" 
        return 0
      elif [[ "${ipv6_port_access}" == True ]] && [[ "${publicIPv4_exist}" == False  ]]
      then
        echo "Open. IPv6: ${ipv6_port_access} & IPv4: N/A"
        return 0
      fi
      
      if [[ "${ipv4_port_access}" == True ]] && [[ "${ipv6_port_access}" == False ]]
      then
        echo "Open. IPv4: ${ipv4_port_access} & IPv6: ${ipv6_port_access}"
        return 0
      elif [[ "${ipv4_port_access}" == False ]] && [[ "${ipv6_port_access}" == True ]]
      then
        echo "Open. IPv4: ${ipv4_port_access} & IPv6: ${ipv6_port_access}"
        return 0
      else
        echo "Error - Teapot"
        return 1
      fi
      
    else
      echo "Error - Couldn't obtain a token for port check"
      return 1
    fi
}

echo "Port check 80|$( is_port_open 80 )"
echo "Port check 443|$( is_port_open 443 )"


# LAN
IFACE=$( ip r | grep "default via" | awk '{ print $5 }' | head -1 )
GW=$(    ip r | grep "default via" | awk '{ print $3 }' | head -1 )
IP="$(get_ip)"

echo "IP|$IP"
echo "Gateway|$GW"
echo "Interface|$IFACE"

# Certificates
CERTS="$( grep "SSLCertificateFile */etc/letsencrypt/live/" /etc/apache2/sites-available/nextcloud.conf \
        | sed 's|.*SSLCertificateFile */etc/letsencrypt/live/||;s|/fullchain.pem||' )"
[[ "$CERTS" == "" ]] && CERTS=none
echo "certificates|$CERTS"

RESOLV="$( ping -c1 -w1 "$CERTS" 2>/dev/null | head -1 | grep -oP '\d{1,3}(.\d{1,3}){3}' )"
echo "NAT loopback|$( [[ "$RESOLV" == "$IP" ]] && echo yes || echo no )"

# Other
echo "Uptime|$( uptime | cut -f1 -d',' | awk '{ $1=""; $2=""; print }' | tr -d "  " )"
# Get kernel version

# License
#
# This script is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this script; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place, Suite 330,
# Boston, MA  02111-1307  USA
